# GitHub Copilot 開発指針

## 採用技術スタック

このブロック崩しRPGは以下の技術スタックで開発します：

### コア技術
- **言語**: TypeScript
- **フレームワーク**: React 18
- **ゲームエンジン**: HTML5 Canvas + カスタムゲームループ
- **状態管理**: Zustand（軽量で型安全）
- **UI**: TailwindCSS（ユーティリティファースト）
- **ビルドツール**: Vite（高速開発・ビルド）
- **テストフレームワーク**: Vitest + React Testing Library
- **リンター**: ESLint + Prettier

### 想定ディレクトリ構造
```
src/
├── components/          # UI コンポーネント
│   ├── ui/             # 再利用可能な基本コンポーネント
│   └── game/           # ゲーム固有のコンポーネント
├── game/               # ゲームロジック
│   ├── engine/         # ゲームエンジン（Canvas、ループ等）
│   ├── entities/       # ゲームオブジェクト（パドル、ボール、ブロック）
│   ├── systems/        # ゲームシステム（経験値、レベル、スキル）
│   └── utils/          # ゲーム用ユーティリティ
├── stores/             # 状態管理（Zustand）
├── hooks/              # カスタムフック
├── types/              # TypeScript型定義
├── constants/          # 定数
└── tests/              # テストファイル
docs/
├── spec.md             # 詳細仕様書
└── api.md              # API仕様（内部API）
```

## 必須開発ルール

### 1. 仕様の追記義務

**機能の追加・変更を行う際は、必ず以下の手順を厳守してください：**

1. **仕様書の更新を最優先**: `docs/spec.md` に関連仕様を先に追記・更新する
2. **実装との整合性確保**: 実装とドキュメントが常に一致するよう維持する
3. **変更理由の明記**: なぜその変更が必要かを仕様書に記載する

**違反例**:
- 先に実装してから後で仕様書を更新する
- 仕様書の更新を忘れて実装のみ進める

**正しい例**:
```
1. spec.mdにスキルシステムの仕様を詳細に記述
2. その仕様に基づいてテストコードを作成
3. テストを通すように実装を進める
```

### 2. テスト駆動開発の実践

**すべての実装において、以下のTDDサイクルを厳格に実行してください：**

#### 新機能開発時
1. **Red**: まず失敗するテストを書く
2. **Green**: テストを通す最小限の実装を行う
3. **Refactor**: コードを改善し、すべてのテストが通ることを確認

#### 既存コード修正時
1. **既存テストの実行**: 修正前に全テストを実行し、現在の状態を把握
2. **テストの追加・修正**: 必要に応じて新しいテストを追加
3. **実装の修正**: テストを通すように修正
4. **デグレード防止**: 全テストを再実行し、既存機能に影響がないことを確認

#### テスト種類別の指針
- **ユニットテスト**: 各関数・クラスの単体動作を検証
- **統合テスト**: コンポーネント間の連携を検証
- **E2Eテスト**: ユーザーの操作フローを検証（主要機能のみ）

### 3. 疎結合で保守性の高い設計

**以下の設計原則を必ず適用してください：**

#### 単一責任の原則
- 1つのクラス・関数は1つの責任のみを持つ
- 関連性の薄い機能を同じファイルに混在させない

#### 依存性の逆転
- 抽象に依存し、具象に依存しない
- インターfaces/型を活用した抽象化を徹底

#### モジュラー設計
- 各機能は独立したモジュールとして実装
- 他のモジュールへの依存を最小限に抑制

**具体的な実装指針**:
```typescript
// ✅ 良い例：責任が明確に分離されている
class GameEngine {
  // ゲームループのみに責任を持つ
}

class PlayerStatsManager {
  // プレイヤーの経験値・レベル管理のみに責任を持つ
}

// ❌ 悪い例：複数の責任が混在
class Game {
  // ゲームループ + 経験値管理 + UI更新 = 責任過多
}
```

## コーディング規約

### TypeScript
- 型安全性を最大限活用する
- `any`の使用を避け、適切な型定義を行う
- Genericsを活用して再利用性を高める

### React
- 関数コンポーネント + Hooks パターンを使用
- カスタムフックで状態ロジックを分離
- propsは明確な型定義を持つ

### ゲーム開発
- Canvas操作は専用のエンジンクラスに集約
- ゲーム状態とUI状態を明確に分離
- フレームレート制御とパフォーマンス最適化を考慮

## コミット・PR規約

### コミットメッセージ
```
feat: 新機能追加
fix: バグ修正
docs: ドキュメント更新
test: テスト追加・修正
refactor: リファクタリング
```

### PR作成時のチェックリスト
- [ ] `docs/spec.md` の関連仕様が更新されている
- [ ] 新機能には対応するテストが追加されている
- [ ] 全てのテストが通っている
- [ ] ESLint・Prettierチェックが通っている
- [ ] 変更内容が設計原則に準拠している

## パフォーマンス指針

### ゲーム固有の最適化
- Canvas描画の最適化（オフスクリーンCanvas等）
- ゲームオブジェクトのオブジェクトプーリング
- 60FPSを維持するためのフレーム制御

### React最適化
- 不要な再レンダリングの防止（React.memo、useMemo、useCallback）
- 状態管理の最適化（Zustandの適切な使用）

この指針に従って、保守性が高く、テストされた、品質の高いブロック崩しRPGを開発してください。